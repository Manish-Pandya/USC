/* ng-infinite-scroll - v1.0.0 - 2013-02-23 */
var mod;
//instantiate an object that controls whether scroller is possible
var disabler = new UserScrollDisabler();

mod = angular.module('infinite-scroll', []);

var lastScrollTop = 0;
function detectDirection(element) {
	//console.log(element);
	direction = 'down';
    st = element.offset().top;
   // console.log(st);
    if (st < lastScrollTop) {
        direction = "down";
    } else {
        direction = "up";
    }

    lastScrollTop = st;
    
    return direction;
    
}

mod.directive('infiniteScroll', [
  '$rootScope', '$window', '$timeout', function($rootScope, $window, $timeout) {
    return {
      link: function(scope, elem, attrs, transclude) {
      	//disabler.disable_scrolling();
      	$window = angular.element($window);

      	//elem.parent().parent().css({"maxHeight":$window.height()+200});
        var checkWhenEnabled, handler, scrollDistance, scrollEnabled;
        var kids = $(elem).children();      
        if(kids.length>15){
        	elem.bind('scroll', handler2);
        	elem.css({"overflow-y":"auto","margin-top":"30px","margin-right":"4px","padding-top":"0px","maxHeight":$window.height()*.9,"borderTop":"3px solid #ccc"});
        }
        function handler2(){
        	console.log($(elem)[0].scrollHeight - $(elem).scrollTop() + " is compared to " + $(elem).outerHeight());

        	var kids = $(elem).children();

        	var topElementWatchBool = $(kids[0]).offset().top + $(kids[0]).height() - elem.offset().top < 1;
        	var bottomElementWatchBool = $(kids[kids.length-1]).offset().top - $(kids[kids.length-1]).height() - 500  < elem.offset().top + elem.height();

        	var direction = detectDirection($(kids[0]));

    		if ($(elem)[0].scrollHeight - $(elem).scrollTop() <= $(elem).outerHeight()) {
        		// var scrollTo = $(elem).inneerHeight()-25;
        		 $(elem).scrollTop(590);
        	}

		//	console.log(direction);
			//bottom element has entered the bottom of the screen, so we should add another element
        	if(bottomElementWatchBool && direction == 'down'){
        		//trigger bottom callback
        		//console.log('should trigger bottom add');
        		//console.log(attrs.infiniteScrollBottomOnScreen);
				if ($rootScope.$$phase) {
					return scope.$eval(attrs.infiniteScrollBottomOnScreen);
				} else {
				  return scope.$apply(attrs.infiniteScrollBottomOnScreen);
				}
        	}


        	//first element has left the top of the screen, so we should remove one
         	if(topElementWatchBool  && direction == 'down'){
				$(elem).scrollTop(10);        		
				//trigger top callback
        		if ($rootScope.$$phase) {
				  return scope.$eval(attrs.infiniteScrollTopOffScreen);
				} else {
				  return scope.$apply(attrs.infiniteScrollTopOffScreen);
				}

        	}else if($(kids[0]).offset().top - $(kids[0]).height() > 0 && direction == 'up'){
        		//console.log('should be adding to top');
        		//the top element is on the screen, so we need more if there are any
        		//console.log('should trigger top add and bottom remove');
        		if ($rootScope.$$phase) {
					return scope.$eval(attrs.infiniteScrollTopOnScreen);
				} else {
				  return scope.$apply(attrs.infiniteScrollTopOnScreen);
				}
        	}
        	

        	//bottom element has entered the bottom of the screen, so we should add another element
        	//we remove a bottom element if the top element enters the screen, and the list is longer than 15, and there are more objects to push


        }

        scope.$watch(elem, function(value) {
        });

        scope.$watch("openedHazard", function(value) {
        	console.log(value);
        	elem.scrollTop = 0;
        },true);

       // console.log(transclude(elem));
        scrollDistance = 0;
        if (attrs.infiniteScrollDistance != null) {
          scope.$watch(attrs.infiniteScrollDistance, function(value) {
            return scrollDistance = parseInt(value, 10);
          });
        }
        scrollEnabled = true;
        checkWhenEnabled = false;
        if (attrs.infiniteScrollDisabled != null) {
          scope.$watch(attrs.infiniteScrollDisabled, function(value) {
            scrollEnabled = !value;
            if (scrollEnabled && checkWhenEnabled) {
              checkWhenEnabled = false;
              return handler();
            }
          });
        }
        scope.$on('$destroy', function() {
         // return $window.off('scroll', handler);
        });
        return $timeout((function() {
          if (attrs.infiniteScrollImmediateCheck) {
            if (scope.$eval(attrs.infiniteScrollImmediateCheck)) {
             // return handler();
            }
          } else {
            //return handler();
          }
        }), 0);
      }
    };
  }
]);